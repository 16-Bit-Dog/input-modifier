//Ariel Glasroth
//break points (f9) saved my life in this program... wow was it good
#include <windows.h>
#include <setupapi.h>
#include <Hidclass.h>
#include <Sensors.h>
#include <sensorsapi.h>
#include <SensorsDef.h>
#include <iostream>
#include <stdio.h>
#include <combaseapi.h>
#include <Devpkey.h>
#include <hidsdi.h>
#include <Devguid.h>
#include <vector>
#include <exception>

#define WIN32_LEAN_AND_MEAN //remove the unneeded

std::vector <int> ProperDevice = {};

int numberOfDevice;

GUID hidGUID = GUID_DEVCLASS_HIDCLASS;

HDEVINFO handle;

const size_t DEVICE_DETAILS_SIZE = sizeof(SP_DEVICE_INTERFACE_DETAIL_DATA) + MAX_PATH;

SP_DEVINFO_DATA type;
PSP_INTERFACE_DEVICE_DETAIL_DATA typePath; // person on stack overflow helped with this issue of delcaring the var
SP_DEVICE_INTERFACE_DATA typePathData;


DEVPROPTYPE name; //name

DWORD length = 0;

bool good = true;

PVOID productN;//get name var
HANDLE product;
LPWSTR namePrintp;

//get buttons vars

HANDLE hHeap = GetProcessHeap(); // to allow me to allocate space to the PHIDP button caps struct and preparsed data
PHIDP_PREPARSED_DATA preparsed;
HIDP_CAPS capsStruct; // has all device essential info
PHIDP_BUTTON_CAPS buttons; // get capability of device (buttons wise)
PHIDP_VALUE_CAPS valueCaps;

ULONG SimpleInputCount; // holds simple input number

DWORD i = 0;

//report input
PCHAR report;
ULONG reportLength;



void GetState(PHIDP_PREPARSED_DATA preparsed, PCHAR report, ULONG reportLength) {



	ULONG rl = HidP_MaxDataListLength(HidP_Input, preparsed); // get max usage size for max usage list length // some thing in this is wrong

	PHIDP_DATA data[250];

	for (int i = 0; i < rl; i++) {

		data[i] = (PHIDP_DATA)malloc(sizeof(PHIDP_DATA));
	

	}

	NTSTATUS hi = HidP_GetData(HidP_Input, reinterpret_cast<PHIDP_DATA>(&data), &rl, preparsed, report, reportLength);

	if (hi == HIDP_STATUS_SUCCESS) {

		std::cout << "\nYAY\n";

	}

	else {

		std::cout << "\n" << hi << "\n";

	}

	if (GetLastError() != 0) {
		std::cout << "\n ERROR: " << GetLastError() << "\n";
	}

	for (int i = 0; i < rl; i++) {

		data[i] = (PHIDP_DATA)malloc(sizeof(PHIDP_DATA));


	}

	for (auto o = 0; o < rl;o) {
	retry:
		o++;

		if (data[o]->On == true) {

			std::cout << "\n button pressed \n";
		
		}
		else {

			std::cout << "\n button NOT pressed \n";

		}

	} // HERE LIES ME PRINTING OUT -data-

	std::cout << "done";


}



void setup() {

	typePathData.cbSize = sizeof(SP_DEVICE_INTERFACE_DATA);

	type.cbSize = sizeof(SP_DEVINFO_DATA);

	HidD_GetHidGuid(&hidGUID);

	handle = SetupDiGetClassDevs(&hidGUID, NULL, NULL, DIGCF_PRESENT | DIGCF_INTERFACEDEVICE);


	if (handle == INVALID_HANDLE_VALUE) // test handle
	{
		std::cout << GetLastError() << "\noof, handle info was done wrong\n\n";

	}


	std::cout << "\nif you see nothing after a while, click enter and everything will load\n\n"; // print number in HID thing to later extract packets from it and look at avaible buttons ect...


	for (i = 0; i == i; i++) { // used the for loop format from Dan77062, Thanks for the neat code format ;)
		SetupDiEnumDeviceInfo(handle, i, &type);

		std::cout << "\nnumber: " << i << "\n\n";
		// get name property

		SetupDiGetDeviceProperty(handle, &type, &DEVPKEY_NAME, &name, NULL, NULL, &length, NULL);
		if (length > 0) {
			namePrintp = (LPWSTR)malloc(length);
			SetupDiGetDeviceProperty(handle, &type, &DEVPKEY_NAME, &name, (PBYTE)namePrintp, length, &length, 0);
			wprintf(L"\nname: %s\n\n", namePrintp);

		}

		// get name
		SetupDiGetDeviceProperty(handle, &type, &DEVPKEY_Device_Manufacturer, &name, NULL, NULL, &length, NULL);
		if (length > 0)
		{

			LPWSTR namePrint = (LPWSTR)malloc(length);
			SetupDiGetDeviceProperty(handle, &type, &DEVPKEY_Device_Manufacturer, &name, (PBYTE)namePrint, length, &length, 0);

			wprintf(L" \nCreator of Device: %s\n\n", namePrint);
			free(namePrint);

			if (GetLastError() == 0) {
				std::cout << "\n property collection is a success\n\n";
			}
			else {

				std::cout << "\n property collection is not a success:" << GetLastError() << "\n\n";

			}
		}

		SetupDiEnumDeviceInterfaces(handle, 0, &hidGUID, i, &typePathData);
		if (GetLastError() == 0) {
			std::cout << "\n interface handling is a success\n\n";
		}
		else {

			std::cout << "\n interface handling is not a success:" << GetLastError() << "\n\n";

		}

		if (GetLastError() == ERROR_NO_MORE_ITEMS) {
			std::cout << "\n interface failed\n\n";
			good = false;
		}

		DWORD size = sizeof(SP_DEVICE_INTERFACE_DETAIL_DATA) + MAX_PATH;


		typePath = (PSP_INTERFACE_DEVICE_DETAIL_DATA)malloc(size);
		typePath->cbSize = sizeof(SP_INTERFACE_DEVICE_DETAIL_DATA);

		SetupDiGetDeviceInterfaceDetail(handle, &typePathData, typePath, size, &size, NULL);

		printf("\n\nMaking Device Handle: %ls \n\n", typePath->DevicePath); //breaking convention of printing due to data not being user important --> but may have use if someone wants a quick easy debug for their own program


		product = CreateFileW(typePath->DevicePath, 0, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, 0, NULL);

		if (GetLastError() == 0) {
			//	std::cout << "\n file handle creation is a success\n\n";
		}
		else {

			std::cout << "\n file handle collection is not a success (or final value is reached):" << GetLastError() << "\n\n";

		}

		if (product == INVALID_HANDLE_VALUE) {
			std::cout << "Handle is invalid \n";
		}


		//get buttons avaible for use

		if (HidD_GetPreparsedData(product, &preparsed)) {

			if (preparsed != NULL) {
				std::cout << "\n preparsed data collected\n\n";
			}
			else {

				std::cout << "\n preparsed data collection FAILED: " << GetLastError() << "\n\n";

			}


			if (HidP_GetCaps(preparsed, &capsStruct)) {

				printf("\n\n usage %x \n\n", capsStruct.Usage);

				hHeap = GetProcessHeap();

				buttons = (PHIDP_BUTTON_CAPS)HeapAlloc(hHeap, 0, sizeof(HIDP_BUTTON_CAPS) * capsStruct.NumberInputButtonCaps);

				HidP_GetButtonCaps(HidP_Input, buttons, &capsStruct.NumberInputButtonCaps, preparsed); // thank you random person on MSDN forums, I had no idea I did not need to use a report type var!


				std::cout << "\n Number of Inputs found:  " << buttons->Range.UsageMax - buttons->Range.UsageMin + 1 << "\n\n";

				if ((buttons->Range.UsageMax - buttons->Range.UsageMin + 1) > 0) {

					ProperDevice.push_back(i);
				}
				else {

					std::cout << "\n INVALID INPUT COUNT \n\n";


				}



			}
		}
		else {

			std::cout << "\n\n\npreparsed data not retrived\n\n";

		}

		HidD_FreePreparsedData(preparsed);
		CloseHandle(product);

		if (good == false) {
			break;
		}

	}
























	std::cout << "Possibley Good Devices: \n\n\n\n\n\n\n";
	for (int x = 0; x < ProperDevice.size(); x++) {

		std::cout << "\n" << ProperDevice[x] << "\n";

	}

	std::cout << "\nchose which device you want to look at (enter number + enter) -> incorrect numbers may cause unexpected results\n"; // remove keyboard and mouse devices
	std::cin >> numberOfDevice;

	// DEVICE CHOSEN

	SetupDiDestroyDeviceInfoList(handle);

	HDEVINFO handle;

	handle = SetupDiGetClassDevs(&hidGUID, NULL, NULL, DIGCF_PRESENT | DIGCF_INTERFACEDEVICE);
















	SetupDiEnumDeviceInfo(handle, numberOfDevice, &type);

	std::cout << "\n\n\n\n\n\n\n\nnnumber: " << numberOfDevice << "\n\n";
	// get name property

	SetupDiGetDeviceProperty(handle, &type, &DEVPKEY_NAME, &name, NULL, NULL, &length, NULL);
	if (length > 0) {
		namePrintp = (LPWSTR)malloc(length);
		SetupDiGetDeviceProperty(handle, &type, &DEVPKEY_NAME, &name, (PBYTE)namePrintp, length, &length, 0);
		wprintf(L"\nname: %s\n\n", namePrintp);



	}

	// get name
	SetupDiGetDeviceProperty(handle, &type, &DEVPKEY_Device_Manufacturer, &name, NULL, NULL, &length, NULL);
	if (length > 0)
	{

		LPWSTR namePrint = (LPWSTR)malloc(length);
		SetupDiGetDeviceProperty(handle, &type, &DEVPKEY_Device_Manufacturer, &name, (PBYTE)namePrint, length, &length, 0);

		wprintf(L" \nCreator of Device: %s\n\n", namePrint);
		free(namePrint);

		//reset type path since it is a mess

		typePathData.cbSize = 0;



		typePathData.cbSize = sizeof(SP_DEVICE_INTERFACE_DATA);

		SetupDiEnumDeviceInterfaces(handle, 0, &hidGUID, numberOfDevice, &typePathData);



		DWORD size = sizeof(SP_DEVICE_INTERFACE_DETAIL_DATA) + MAX_PATH;


		typePath = (PSP_INTERFACE_DEVICE_DETAIL_DATA)malloc(size);
		typePath->cbSize = sizeof(SP_INTERFACE_DEVICE_DETAIL_DATA);





		SetupDiGetDeviceInterfaceDetail(handle, &typePathData, typePath, size, &size, NULL);



		printf("\n\nMaking Device Handle: %ls \n\n", typePath->DevicePath); //breaking convention of printing due to data not being user important --> but may have use if someone wants a quick easy debug for their own program


		product = CreateFileW(typePath->DevicePath, 0, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, 0, NULL);





		if (HidD_GetPreparsedData(product, &preparsed)) {



			if (HidP_GetCaps(preparsed, &capsStruct)) {

				hHeap = GetProcessHeap();
				//pre-fill most needed items

				buttons = (PHIDP_BUTTON_CAPS)HeapAlloc(hHeap, 0, sizeof(HIDP_BUTTON_CAPS) * capsStruct.NumberInputButtonCaps);
				//

				HidP_GetButtonCaps(HidP_Input, buttons, &capsStruct.NumberInputButtonCaps, preparsed); // thank you random person on MSDN forums, I had no idea I did not need to use a report type var

				SimpleInputCount = buttons->Range.UsageMax - buttons->Range.UsageMin + 1;

				std::cout << "\n Number of Inputs found:  " << buttons->Range.UsageMax - buttons->Range.UsageMin + 1 << "\n\n";


				report = (PCHAR)malloc(size);

				reportLength = capsStruct.InputReportByteLength;

				HidP_InitializeReportForID(HidP_Input, buttons->ReportID, preparsed, report, reportLength); // get report











				//HidP_GetUsages(HidP_Input, buttons->UsagePage, 0, usage, &rl, preparsed, report, reportLength);//get button states, thanks to https://www.codeproject.com/Articles/185522/Using-the-Raw-Input-API-to-Process-Joystick-Input
				// now I have all buttons on the usage page --> that are on or off state (so not analog triggers for example)


				GetState(preparsed,report,reportLength);


			}



		}
	}
}





int main() {

	setup();

	
}


// THIS BELOW CODE HELPS GET ADVANCED BUTTONS LIKE TRIGGERS, and their values!!! --> anything that is not on or off, like sensors (I think)
/*if (&capsStruct.NumberInputValueCaps > 0) {

	valueCaps = (PHIDP_VALUE_CAPS)HeapAlloc(hHeap, 0, SimpleInputCount * sizeof(HIDP_VALUE_CAPS));

	HidP_GetValueCaps()
}*/
